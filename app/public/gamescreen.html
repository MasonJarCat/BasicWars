<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Gamescreen</title>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <h1 id="gametitle"></h1>

    <p>Welcome to the game!</p>

    <p id="maptitle"></p>
    <div id="economyInfo"></div>
    <div id="user_id"></div>
    <button id="endturnbutton">End Turn</button>

    <div id="selectedunitmenu"></div>

    <div id="unitproductionmenu"></div>

</body>

<script src="https://pixijs.download/release/pixi.js"></script>

<script type="module">  
    //todo add gameunit rendering from past game state. //rest the unit table. drop all units created in a game when  the game is over(do this server side ) 
    let gametitle = document.getElementById("gametitle");
    let unitproductionmenu = document.getElementById("unitproductionmenu");
    let economyInfo = document.getElementById("economyInfo");
    let selectedunitmenu = document.getElementById("selectedunitmenu");
    let endturnbutton = document.getElementById("endturnbutton");

    let gamedata;
    let unittypes;
    let terraintypes;
    let gameunits;
    let mapdata;
    let querystring = window.location.href.slice(window.location.href.indexOf('?'));
    let selectedUnit;
    let selectedUnitMovableTiles;
    let selectedUnitAttackableTiles;
    let income; 
    let funds; 
    let movingselectedunit = false;
    let attackWithUnit = false;
    let attacking_unit;
    let fogEnabled;
    let fogLayer; 
    let visibleTiles;
    let isPlayer1Turn;
    let currentPlayerId;
    let app = new PIXI.Application();
    let mapterrain = new Array();
    function showUserInfo() {
        const userInfoDiv = document.getElementById('user_id');
        const userId = getUserId();
    
        if (userId) {
            console.log('User ID found: ', userId); // Debugging log
            userInfoDiv.textContent = 'Logged in as User ID: ' + userId;
        } else {
            console.log('No User ID found'); // Debugging log
            userInfoDiv.textContent = 'User not logged in';
        }
    }
    
    function getUserId() {
        // Example: Retrieve user ID from a cookie, local storage, or a server API call
        const userIdFromCookies = getCookie('userId');
        console.log('User ID from Cookies: ', userIdFromCookies); // Debugging log
        if (userIdFromCookies) {
            return userIdFromCookies;
        }
    
        const userIdFromLocalStorage = localStorage.getItem('userId');
        console.log('User ID from Local Storage: ', userIdFromLocalStorage); // Debugging log
        if (userIdFromLocalStorage) {
            return userIdFromLocalStorage;
        }
    
        return null; 
    }
    
    // Helper function to get a cookie by name
    function getCookie(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) {
            const cookieValue = parts.pop().split(';').shift();
            console.log('Cookie found:', name, '=', cookieValue); // Debugging log
            return cookieValue;
        }
        console.log('Cookie not found:', name); // Debugging log
        return null;
    }

    async function initGame() {
        // Initialize PIXI app without passing options directly
        
        await app.init({ width: 640, height: 360 });
    
        // Append the canvas to the body using `canvas` instead of `view`
        document.body.appendChild(app.canvas);
    
        console.log(querystring);
    
        // Load assets
        const assetPromises = [
            PIXI.Assets.load('neutralfactory.png'),
            PIXI.Assets.load('neutralHQ.png'),
            PIXI.Assets.load('redfactory.png'),
            PIXI.Assets.load('redHQ.png'),
            PIXI.Assets.load('bluefactory.png'),
            PIXI.Assets.load('blueHQ.png'),
            PIXI.Assets.load('plains.png'),
            PIXI.Assets.load('mountain.png'),
            PIXI.Assets.load('forest.png'),
            PIXI.Assets.load('neutralairport.png'),
            PIXI.Assets.load('redairport.png'),
            PIXI.Assets.load('blueairport.png'),
            PIXI.Assets.load('neutralsettlement.png'),
            PIXI.Assets.load('redsettlement.png'),
            PIXI.Assets.load('bluesettlement.png'),
            PIXI.Assets.load('redinfantry.png'),
            PIXI.Assets.load('blueinfantry.png'),
            PIXI.Assets.load('blueantiair.png'),          
            PIXI.Assets.load('redantiair.png'),           
            PIXI.Assets.load('neutralantiair.png'),
            PIXI.Assets.load('blueartillery.png'),
            PIXI.Assets.load('redartillery.png'),
            PIXI.Assets.load('neutralartillery.png'),
            PIXI.Assets.load('bluebomber.png'),
            PIXI.Assets.load('redbomber.png'),
            PIXI.Assets.load('neutralbomber.png'),
            PIXI.Assets.load('bluefighter.png'),
            PIXI.Assets.load('redfighter.png'),
            PIXI.Assets.load('neutralfighter.png'),
            PIXI.Assets.load('blueheavytank.png'),
            PIXI.Assets.load('redheavytank.png'),
            PIXI.Assets.load('neutralheavytank.png'),
            PIXI.Assets.load('bluehelicopter.png'),
            PIXI.Assets.load('redhelicopter.png'),
            PIXI.Assets.load('neutralhelicopter.png'),
            PIXI.Assets.load('bluelighttank.png'),
            PIXI.Assets.load('redlighttank.png'),
            PIXI.Assets.load('neutrallighttank.png'),
            PIXI.Assets.load('bluemechinfantry.png'),
            PIXI.Assets.load('redmechinfantry.png'),
            PIXI.Assets.load('neutralmechinfantry.png'),
            PIXI.Assets.load('bluerecon.png'),
            PIXI.Assets.load('redrecon.png'),
            PIXI.Assets.load('neutralrecon.png'),
            PIXI.Assets.load('bluerocketarty.png'),
            PIXI.Assets.load('redrocketarty.png'),
            PIXI.Assets.load('neutralrocketarty.png'),
            PIXI.Assets.load('fog.png')
        ];
    
        await Promise.all(assetPromises);
    
        // The rest of your initialization and fetch logic remains the same
        // Function to display the current user's information

        // Fetch terrain types
        const terrainResponse = await fetch("/terraintypes", { method: "GET" });
        const terrainBody = await terrainResponse.json();
        terraintypes = terrainBody.rows;

        // Fetch unit types
        const unitResponse = await fetch("/unittypes", { method: "GET" });
        const unitBody = await unitResponse.json();
        unittypes = unitBody.rows;

        // Fetch game units
        const gameUnitsResponse = await fetch("/gameunits" + querystring, { method: "GET" });
        const gameUnitsBody = await gameUnitsResponse.json();
        gameunits = gameUnitsBody.rows;

        // Fetch map data
        const mapResponse = await fetch("/map" + querystring, { method: "GET" });
        const mapBody = await mapResponse.json();
        if (mapBody.rows.length <= 0) {
            console.log("No game found");
        } else {
            mapdata = mapBody.rows[0];
            maptitle.textContent = mapdata.title;
            buildMap(mapdata);
        }

        const gameStateResponse = await fetch("/game" + querystring, { method: "GET" });
        const gameStateBody = await gameStateResponse.json();
        if (gameStateBody.rows.length <= 0) {
            console.log("No game found");
        } else {
            initializeGameState(gameStateBody.rows[0], app);
            showUserInfo();
        }
    }

    function buildMap(mapdata) {
        for (let i = 0; i < mapdata.terrain.length; i++) {
            let row = mapdata.terrain[i];
            let ownerRow = mapdata.cellowner[i];
            let y = i * 16;
            for (let j = 0; j < row.length; j++) {
                let x = j * 16;
                let type = row[j];
                let typeData = terraintypes[type - 1];
                let owner = ownerRow[j];
                let spriteName; 
                if (typeData['capturable']) {
                    if (owner == 0) {
                        spriteName = 'neutral' + typeData['title'] + '.png';
                    } else if (owner == 1) {
                        spriteName = 'red' + typeData['title'] + '.png';
                    } else {
                        spriteName = 'blue' + typeData['title'] + '.png';
                    }
                } else {
                    spriteName = typeData['title'] + '.png';
                }
                let sprite = PIXI.Sprite.from(spriteName);
                terrainBuilder(sprite, x, y, j, i, typeData);
            }
        }
    }
    function drawUnits() {
        // Loop through all game units and place them on the map
        for (let i = 0; i < gameunits.length; i++) {
            let unit = gameunits[i];
            let unitType = unittypes.find(type => type.id === unit.type_id);
            
            // Determine the sprite name based on the player's color (red or blue)
            let spriteName = (unit.player_id === gamedata.p1_id ? 'red' : 'blue') + unitType.title + '.png';
            
            // Create the sprite for the unit
            let unitSprite = PIXI.Sprite.from(spriteName);
            
            // Position the sprite on the map
            unitSprite.x = unit.pos_x * 16; // Assuming each tile is 16x16 pixels
            unitSprite.y = unit.pos_y * 16;
            
            // Set event handler for clicking the unit
            unitSprite.on('click', (event) => onClickUnit(unitSprite, unitType, unit));
            unitSprite.eventMode = 'dynamic';
            
            // Add the sprite to the PIXI application stage
            app.stage.addChild(unitSprite);
            
            // Store the sprite in the unit data for future reference (e.g., moving the unit)
            unit.sprite = unitSprite;
        }
    }
    function initializeGameState(gameState, app) {
        fogLayer = new Array();
        gametitle.textContent = gameState.title;
        gamedata = gameState;
        currentPlayerId = getCookie("userId"); 
        
        if (gamedata["turn"] % 2 === 1) {
            isPlayer1Turn = true;
            income = gamedata.p1_income;
            funds = gamedata.p1_funds;
        } else {
            isPlayer1Turn = false;
            income = gamedata.p2_income;
            funds = gamedata.p2_funds;
        }
        fogEnabled = gamedata['fog'];
        economyInfo.textContent = "income: " + income + "\nfunds: " + funds;
        // If it's not the player's turn, disable actions
        endturnbutton.style.display = 'block';
        if ((isPlayer1Turn && parseInt(currentPlayerId) !== gamedata.p1_id) || (!isPlayer1Turn && parseInt(currentPlayerId) !== gamedata.p2_id)) {
            endturnbutton.style.display = 'none';  // Hide the "End Turn" button
            console.log(isPlayer1Turn);
            console.log(gamedata.p2_id);
            console.log(currentPlayerId);
            disableActions();  // Disable unit selection, movement, etc.
        }
        drawUnits();
        if (fogEnabled) {
            drawFog(app);
        }
    }

    initGame();
    function disableActions() {
        // Disable unit selection, movement, and attacks
        document.querySelectorAll('button').forEach(button => {
            button.disabled = true;
        });
        document.querySelectorAll('canvas').forEach(canvas => {
            canvas.style.pointerEvents = 'none';
        });
    }

    function drawFog(){
        let visibleTiles = new Array(); 
        for (let i = 0; i < gamedata['tile_owners'].length; i++){
            let ownerRow = gamedata['tile_owners'][i];
            for (let j = 0; j < ownerRow.length; j++){
                if ((parseInt(currentPlayerId) === gamedata.p1_id && ownerRow[j] === 1) || (parseInt(currentPlayerId) === gamedata.p2_id && ownerRow[j] === 2)) {
                    visibleTiles.push({'x': j, 'y': i});
                }
            }
        }
        for (let k = 0; k < gameunits.length; k++){
            let unit = gameunits[k];
            if ((parseInt(currentPlayerId) === gamedata.p1_id && isPlayer1Turn && unit.player_id === gamedata.p1_id) || (parseInt(currentPlayerId) === gamedata.p2_id && !isPlayer1Turn && unit.player_id === gamedata.p2_id)) {
                let unitStats = unittypes[unit['type_id'] - 1]; 
                for (let i = 0; i < mapterrain.length; i++){
                    let dx = mapterrain[i]['pos_x'] - unit['pos_x'];
                    let dy = mapterrain[i]['pos_y'] - unit['pos_y'];
                    let distance = Math.abs(dx) + Math.abs(dy);
                    if (distance <= unitStats['sightrange']){
                        let extantTile = visibleTiles.find(c => c['x'] == mapterrain[i]['pos_x'] && c['y'] == mapterrain[i]['pos_y']);
                        if (extantTile === undefined){
                            visibleTiles.push({'x': mapterrain[i]['pos_x'], 'y': mapterrain[i]['pos_y']});
                        }
                    }
                }
            }
        }
        fogLayer.forEach(sprite => sprite.parent.removeChild(sprite));
        fogLayer = new Array();
        mapterrain.forEach(mapTile => {
            let visibleTile = visibleTiles.find(c => c['x'] == mapTile['pos_x'] && c['y'] == mapTile['pos_y']);
            if (visibleTile === undefined){
                let fogSprite = PIXI.Sprite.from('fog.png'); 
                fogSprite.x = mapTile['pos_x'] * 16;
                fogSprite.y = mapTile['pos_y'] * 16;
                fogSprite.zIndex = 2;
                app.stage.addChild(fogSprite);
                fogLayer.push(fogSprite);
            }
        });
    }

    function onClickTerrain(terrain, x, y, type){
        if (selectedUnit && movingselectedunit){
            let goalCell = selectedUnitMovableTiles.find(c => c['pos_x'] == x && c['pos_y'] == y);
            if (goalCell){
                selectedUnit.sprite.x = terrain.x;
                selectedUnit.sprite.y = terrain.y;
                selectedUnit.stats.pos_x = x;
                selectedUnit.stats.pos_y = y;
                selectedUnit['stats']['can_move_this_turn'] = false; 
                if (fogEnabled){
                    drawFog();
                }
                updateUnitStats(selectedUnit);
            } else {
                console.log('Out of range');
            }
        } else {
            if (type['canprintunits']){
                type['unitprintlist'].forEach(unitTypeID => {
                    let unitType = unittypes.find(c => c['id'] == unitTypeID);
                    let printRow = document.createElement('div'); 
                    printRow.textContent = unitType['title'] + ", " + unitType['cost']; 
                    let buybutton = document.createElement('button');
                    buybutton.addEventListener('click', () => buyUnit(unitType, x, y, terrain.x, terrain.y));
                    buybutton.textContent = "buy";
                    printRow.append(buybutton);
                    unitproductionmenu.append(printRow);
                });
            }
        }
        selectedUnit = null; 
        movingselectedunit = false;
        clearUnitMenu();
    }

    function buyUnit(unitType, gamex, gamey, mapx, mapy) {
        let unitSpriteName = (isPlayer1Turn ? 'red' : 'blue') + unitType['title'] + '.png';
    
        if (funds >= unitType['cost']) {
            funds -= unitType['cost'];
            if (isPlayer1Turn) {
                gamedata.p1_funds = funds;
            } else {
                gamedata.p2_funds = funds;
            }
    
            let unitData = {
                type_id: unitType['id'],
                game_id: gamedata['id'],
                player_id: isPlayer1Turn ? gamedata.p1_id : gamedata.p2_id,
                pos_x: gamex,
                pos_y: gamey,
                isP1: isPlayer1Turn
            };
            fetch("/add/unit", {
                method: "POST",
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(unitData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.unit_id) {
                    let stats = {
                        id: data.unit_id,
                        type_id: unitType['id'],
                        game_id: gamedata['id'],
                        player_id: unitData.player_id,
                        pos_x: gamex,
                        pos_y: gamey,
                        cur_hp: 10,
                        capturing: false,
                        capture_prog: 0,
                        can_move_this_turn: false,
                        can_attack_this_turn: false,
                        can_capture_this_turn: false
                    };
                    gameunits.push(stats);
    
                    let newsprite = PIXI.Sprite.from(unitSpriteName);
                    newsprite.on('click', (event) => onClickUnit(newsprite, unitType, stats));
                    newsprite.eventMode = 'dynamic';
                    newsprite.x = mapx;
                    newsprite.y = mapy;
                    app.stage.addChild(newsprite);
    
                    economyInfo.textContent = "income: " + income + "\nfunds: " + funds;
                    if (fogEnabled) {
                        drawFog();
                    }
                } else {
                    console.log('Failed to add unit to the server.');
                }
            })
            .catch(error => {
                console.error("Error adding unit:", error);
            });
        } else {
            console.log('Insufficient funds!');
        }
    
        let j = unitproductionmenu.children.length - 1;
        while (j >= 0) {
            unitproductionmenu.children[j].remove();
            j--;
        }
    

    }

    function terrainBuilder(sprite, spritex, spritey, posx, posy, type){
        sprite.y = spritey;
        sprite.x = spritex;
        sprite.on('click', (event) => onClickTerrain(sprite, posx, posy, type));
        sprite.eventMode = 'dynamic';
        mapterrain.push({'sprite': sprite, 'type': type, 'pos_x': posx, 'pos_y': posy})
        sprite.zIndex = -1;
        app.stage.addChild(sprite);
    }

    function onClickUnit(sprite, type, stats) {
        clearUnitMenu();
        selectedUnit = { 'sprite': sprite, 'type': type, 'stats': stats };
    
        // Check if the current player owns the unit
        const currentPlayerOwnsUnit = 
            (parseInt(currentPlayerId) === gamedata.p1_id && isPlayer1Turn && stats.player_id === gamedata.p1_id) ||
            (parseInt(currentPlayerId) === gamedata.p2_id && !isPlayer1Turn && stats.player_id === gamedata.p2_id);
    
        // Only allow attack with units owned by the current player
        if (attackWithUnit) {
            console.log('Attacking unit:', selectedUnit, 'Stats:', selectedUnit.stats);
            attackUnit(attacking_unit, selectedUnit);
        }
    
        // Initialize movable and attackable tile arrays
        selectedUnitMovableTiles = [];
        selectedUnitAttackableTiles = [];
    
        // Display unit stats
        let statblock = document.createElement('p');
        statblock.textContent = 'unit type: ' + type['title'] + ', hp: ' + stats['cur_hp'];
        selectedunitmenu.append(statblock);
    
        let occupiedTile = mapterrain.find(c => c['pos_x'] == stats['pos_x'] && c['pos_y'] == stats['pos_y']);
        let occupiedTileOwner = gamedata['tile_owners'][stats['pos_y']][stats['pos_x']];
    
        // Allow movement and capturing only if the player owns the unit
        if (currentPlayerOwnsUnit) {
            // Handle movement
            if (stats['can_move_this_turn']) {
                let movebutton = document.createElement('button');
                movebutton.textContent = 'Move';
    
                for (let i = 0; i < mapterrain.length; i++) {
                    let dx = mapterrain[i]['pos_x'] - stats['pos_x'];
                    let dy = mapterrain[i]['pos_y'] - stats['pos_y'];
                    let distance = Math.abs(dx) + Math.abs(dy);
    
                    if (distance <= selectedUnit.type.speed) {
                        selectedUnitMovableTiles.push(mapterrain[i]);
                    }
                    if (distance >= selectedUnit.type.minrange && distance <= selectedUnit.type.maxrange) {
                        selectedUnitAttackableTiles.push(mapterrain[i]);
                    }
                }
    
                movebutton.addEventListener('click', () => moveUnit(sprite, type, stats));
                selectedunitmenu.append(movebutton);
            }
    
            // Handle capturing
            if (stats['can_capture_this_turn'] && occupiedTile['type']['capturable'] && (occupiedTileOwner != (isPlayer1Turn ? 1 : 2))) {
                let capturebutton = document.createElement('button');
                capturebutton.textContent = 'Capture';
                capturebutton.addEventListener('click', () => captureTile(occupiedTile, stats['pos_x'], stats['pos_y']));
                selectedunitmenu.append(capturebutton);
            }
        
            // Allow attacking if the unit belongs to the player and has attack abilities
            if (stats['can_attack_this_turn']) {
                let attackButton = document.createElement('button');
                attackButton.textContent = 'Attack';
                attackButton.addEventListener('click', () => setAttack(sprite, type, stats));
                selectedunitmenu.append(attackButton);
            }
        }
    }
    
    
    function setAttack(sprite, type, stats) {
        attacking_unit = { 'sprite': sprite, 'type': type, 'stats': stats };
        attackWithUnit = true;
    }
    
    function calculateDamage(unit1, unit2) {
        const healthFactor1 = unit1.cur_hp / 10;
        const healthFactor2 = unit2.cur_hp / 10;
        const damageToUnit1 = Math.max((unit2.attack_power * healthFactor2) - unit1.armor, 0);
        const damageToUnit2 = Math.max((unit1.attack_power * healthFactor1) - unit2.armor, 0);
    
        return { damageToUnit1, damageToUnit2 };
    }
    
    function attackUnit(attackingUnit, targetUnit) {
        console.log('Attacking unit:', attackingUnit, 'Stats:', attackingUnit.stats);
        
        if (!attackingUnit || !targetUnit) {
            console.log('One or both units not found.');
            return;
        }
    
        if (!isTargetInRange(attackingUnit, targetUnit)) {
            console.log('Target is out of range.');
            return;
        }
    
        if (attackingUnit.stats.player_id === targetUnit.stats.player_id) {
            console.log('Cannot attack units of the same team.');
            return;
        }
    
        attackWithUnit = false;
        attacking_unit['stats']['can_attack_this_turn'] = false;
    
        const { damageToUnit1, damageToUnit2 } = calculateDamage(attackingUnit.stats, targetUnit.stats);
    
        attackingUnit.stats.cur_hp -= damageToUnit1;
        targetUnit.stats.cur_hp -= damageToUnit2;
    
        if (attackingUnit.stats.cur_hp <= 0) {
            console.log(`${attackingUnit.type.title} has been destroyed!`);
            removeUnitFromGame(attackingUnit);
        }
    
        if (targetUnit.stats.cur_hp <= 0) {
            console.log(`${targetUnit.type.title} has been destroyed!`);
            removeUnitFromGame(targetUnit);
        }
    
        updateUnitStats(attackingUnit);
        updateUnitStats(targetUnit);
    }
    

    function setAttack(sprite, type, stats){
        attacking_unit = {'sprite': sprite, 'type': type, 'stats': stats};
        attackWithUnit = true;
    }

    function calculateDamage(unit1, unit2) {
        const healthFactor1 = unit1.cur_hp / 10;
        const healthFactor2 = unit2.cur_hp / 10;
        const damageToUnit1 = Math.max((unit2.attack_power * healthFactor2) - unit1.armor, 0);
        const damageToUnit2 = Math.max((unit1.attack_power * healthFactor1) - unit2.armor, 0);
    
        return { damageToUnit1, damageToUnit2 };
    }

    function attackUnit(attackingUnit, targetUnit) {
        console.log(`attacking unit: ${attackingUnit},stats ${attackingUnit.stats}`);
        if (!attackingUnit || !targetUnit) {
            console.log('One or both units not found.');
            return;
        }
        if (!isTargetInRange(attackingUnit, targetUnit)) {
            console.log('Target is out of range.');
            return;
        }
        if (attackingUnit.stats.player_id === targetUnit.stats.player_id) {
            console.log('Cannot attack units of the same team.');
            return;
        }
        attackWithUnit = false;
        attacking_unit['stats']['can_attack_this_turn'] = false; 
        const { damageToUnit1, damageToUnit2 } = calculateDamage(attackingUnit.stats, targetUnit.stats);
    
        attackingUnit.stats.cur_hp -= damageToUnit1;
        targetUnit.stats.cur_hp -= damageToUnit2;
    
        if (attackingUnit.stats.cur_hp <= 0) {
            console.log(`${attackingUnit.type.title} has been destroyed!`);
            removeUnitFromGame(attackingUnit);
        }
    
        if (targetUnit.stats.cur_hp <= 0) {
            console.log(`${targetUnit.type.title} has been destroyed!`);
            removeUnitFromGame(targetUnit);
        }
    
        updateUnitStats(attackingUnit);
        updateUnitStats(targetUnit);
    }

    function removeUnitFromGame(unit) {
        unit.sprite.parent.removeChild(unit.sprite);
        const index = gameunits.indexOf(unit.stats);
        if (index !== -1) {
            gameunits.splice(index, 1);
        }
        clearUnitMenu();
    }
    
    function updateUnitStats(unit) {
        console.log(`Updated ${unit.type.title} HP: ${unit.stats.cur_hp}`);
    
        // Create an object with only the relevant stats
        const relevantStats = {
            unit_id: unit.stats.id,
            cur_hp: unit.stats.cur_hp,
            capturing: unit.stats.capturing,
            capture_prog: unit.stats.capture_prog,
            can_capture_this_turn: unit.stats.can_capture_this_turn,
            can_move_this_turn: unit.stats.can_move_this_turn,
            can_attack_this_turn: unit.stats.can_attack_this_turn,
            pos_x: unit.stats.pos_x,
            pos_y: unit.stats.pos_y
        };
    
        fetch("/update/unit", {
            method: "POST",
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(relevantStats)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log("Unit stats updated successfully");
            } else {
                console.log("Failed to update unit stats");
            }
        })
        .catch(error => {
            console.error("Error updating unit stats:", error);
        });
    }

    
    function isTargetInRange(attackingUnit, targetUnit) {
        console.log(`attacking unit: ${attackingUnit},stats ${attackingUnit.stats}`);
        const dx = Math.abs(attackingUnit.stats.pos_x - targetUnit.stats.pos_x);
        const dy = Math.abs(attackingUnit.stats.pos_y - targetUnit.stats.pos_y);
        const distance = dx + dy;

        return distance >= attackingUnit.type.minrange && distance <= attackingUnit.type.maxrange;
    }

    function moveUnit(sprite, type, stats) {
        movingselectedunit = true;
        stats['capture_prog'] = 0;
        stats['capturing'] = false;

    }

    function captureTile(tile, x, y){
        let stats = selectedUnit['stats'];
        stats['capturing'] = true;
        stats['capture_prog'] += stats['cur_hp']; 
        if (stats['capture_prog'] >= 20){
            tile.sprite.parent.removeChild(tile.sprite);
            let newspritename = (isPlayer1Turn ? 'red' : 'blue') + tile['type']['title'] + '.png';
            let newsprite = PIXI.Sprite.from(newspritename);
            let oldTileIndex = mapterrain.findIndex(c => c['pos_x'] == x && c['pos_y'] == y); 
            mapterrain.splice(oldTileIndex, 1);
            terrainBuilder(newsprite, tile.sprite.x, tile.sprite.y, x, y, tile['type']);
            gamedata['tile_owners'][y][x] = isPlayer1Turn ? 1 : 2;
            if (tile['type']['id'] == 4){
                income += 10;
                economyInfo.textContent = "income: " + income + ", funds: " + funds;
            }
            stats['capture_prog'] = 0;
            stats['capturing'] = false;
        }
        stats['can_move_this_turn'] = false;
        stats['can_attack_this_turn'] = false;
        clearUnitMenu();
    }

    function clearUnitMenu(){
        while (selectedunitmenu.firstChild) {
            selectedunitmenu.removeChild(selectedunitmenu.firstChild);
        }
    }

    function updateGame() {
        console.log(gamedata.turn);
    
        const player1Units = gameunits.filter(unit => unit.player_id === 1).map(unit => unit.id);
        const player2Units = gameunits.filter(unit => unit.player_id === 2).map(unit => unit.id);
    
        const gameStateUpdate = {
            p1_units: isPlayer1Turn ? player1Units : gamedata.p1_units,
            p2_units: !isPlayer1Turn ? player2Units : gamedata.p2_units,
            p1_funds: isPlayer1Turn ? funds : gamedata.p1_funds,
            p2_funds: !isPlayer1Turn ? funds : gamedata.p2_funds,
            p1_income: isPlayer1Turn ? income : gamedata.p1_income,
            p2_income: !isPlayer1Turn ? income : gamedata.p2_income,
            tile_owners: gamedata.tile_owners,
            fog: fogEnabled,
            turn: gamedata.turn + 1
        };
    
        fetch("/updateGameState" + querystring, {
            method: "POST",
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(gameStateUpdate)
        })
        .then(response => {
            if (response.ok) {
                console.log("Game state updated successfully.");
            } else {
                console.log("Failed to update game state.");
            }
        })
        .catch(error => {
            console.error("Error updating game state:", error);
        });
    }
    
    endturnbutton.addEventListener("click", endTurn);
    function endTurn() {
        // Disable the End Turn button to prevent multiple submissions
        endturnbutton.disabled = true;
    
        // Reset unit actions for the next turn
        for (let i = 0; i < gameunits.length; i++) {
            gameunits[i]['can_move_this_turn'] = true;
            gameunits[i]['can_attack_this_turn'] = true;
            gameunits[i]['can_capture_this_turn'] = true;
        }
    
        // Update funds and display the updated economy info
        funds += income;
        economyInfo.textContent = "income: " + income + ", funds: " + funds;
    
        // Clear the selected unit menu
        clearUnitMenu();
    
        // Update the game state on the server
        updateGame();
    
        // Determine whose turn is next and update the visuals accordingly
        if (gamedata["turn"] % 2 === 0) {
            isPlayer1Turn = true;
            income = gamedata.p1_income;
            funds = gamedata.p1_funds;
            gametitle.textContent = "Player 1's Turn";
        } else {
            isPlayer1Turn = false;
            income = gamedata.p2_income;
            funds = gamedata.p2_funds;
            gametitle.textContent = "Player 2's Turn";
        }
    
        // Check if it's the current player's turn; if not, hide the End Turn button
        if ((isPlayer1Turn && parseInt(currentPlayerId) !== gamedata.p1_id) || (!isPlayer1Turn && currentPlayerId !== gamedata.p2_id)) {
            endturnbutton.style.display = 'none'; // Hide the "End Turn" button
            disableActions();  // Disable unit selection, movement, etc.
        } else {
            endturnbutton.style.display = 'inline-block'; // Show the "End Turn" button
            endturnbutton.disabled = false; // Enable the "End Turn" button for the new turn
        }
    }
</script>

</html>
