<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Gamescreen</title>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <h1 id="gametitle"></h1>

    <p>Welcome to the game!</p>

    <p id="maptitle"></p>
    <div id="economyInfo"></div>

    <button id="endturnbutton">End Turn</button>

    <div id="selectedunitmenu"></div>

    <div id="unitproductionmenu"></div>


</body>

<script src="https://pixijs.download/release/pixi.js"></script>

<script type="module">   

    let gametitle = document.getElementById("gametitle");
    let unitproductionmenu = document.getElementById("unitproductionmenu");
    let economyInfo = document.getElementById("economyInfo");
    let selectedunitmenu = document.getElementById("selectedunitmenu");
    let endturnbutton = document.getElementById("endturnbutton");

    let gamedata;
    let unittypes;
    let terraintypes;
    let gameunits;
    let mapdata;
    let querystring = window.location.href.slice(window.location.href.indexOf('?'));
    let selectedUnit;
    let selectedUnitMovableTiles;
    let selectedUnitAttackableTiles;
    let income; 
    let funds; 
    let movingselectedunit = false;
    let attackWithUnit = false;
    let attacking_unit;

    let mapterrain = new Array();
    const app = new PIXI.Application();
    await app.init({ width: 640, height: 360 })
    document.body.appendChild(app.canvas);
    console.log(querystring);
    await PIXI.Assets.load('neutralfactory.png');
    await PIXI.Assets.load('neutralHQ.png');
    await PIXI.Assets.load('redfactory.png');
    await PIXI.Assets.load('redHQ.png');
    await PIXI.Assets.load('bluefactory.png');
    await PIXI.Assets.load('blueHQ.png');
    await PIXI.Assets.load('plains.png');
    await PIXI.Assets.load('neutralsettlement.png');
    await PIXI.Assets.load('redsettlement.png');
    await PIXI.Assets.load('bluesettlement.png');
    await PIXI.Assets.load('redinfantry.png');
    await PIXI.Assets.load('blueinfantry.png');

    fetch("/terraintypes", {
        method: "GET"
    }).then(response => {
        console.log("terrain types fetched");
        return response.json();
    }).then(body => {
        terraintypes = body.rows;
        console.log(terraintypes);
    })

    fetch("/unittypes", {
        method: "GET"
    }).then(response => {
        console.log("unit types fetched");
        return response.json();
    }).then(body => {
        unittypes = body.rows;
    });

    fetch("/gameunits" + querystring, {
        method: "GET"
    }).then(response => {
        console.log("game units fetched");
        return response.json();
    }).then(body => {
        gameunits = body.rows;
    })

    fetch("/map" + querystring, {
        method: "GET"
    }).then(response => {
        console.log("map fetched");
        return response.json();
    }).then(body => {
        if (body.rows.length <= 0){
            console.log("No game found")
        } else {
            mapdata = body.rows[0]
            maptitle.textContent = mapdata.title;
            for (let i = 0; i < mapdata.terrain.length; i++){
                let row = mapdata.terrain[i];
                let ownerRow = mapdata.cellowner[i];
                console.log(row);
                let y = i * 16;
                for (let j = 0; j < row.length; j++){
                    let x = j * 16;
                    let type = row[j];
                    console.log(type);
                    let typeData = terraintypes[type - 1];
                    console.log("type data: ");
                    console.log(typeData);
                    let owner = ownerRow[j];
                    let spriteName; 
                    if (typeData['capturable']){
                        if (owner == 0){
                            spriteName = 'neutral' + typeData['title'] + '.png';
                        } else if (owner == 1){
                            spriteName = 'red' + typeData['title'] + '.png';
                        } else {
                            spriteName = 'blue' + typeData['title'] + '.png';
                        }
                    } else {
                        spriteName = typeData['title'] + '.png';
                    }
                    let sprite = PIXI.Sprite.from(spriteName);
                    terrainBuilder(sprite, x, y, j, i, typeData);
                }
            }
        }
    })

    fetch("/game" + querystring, {
        method: "GET"
    }).then(response => {
        console.log("game fetched");
        return response.json();
    }).then(body => {
    if (body.rows.length <= 0){
            console.log("No game found")
        } else {
            gametitle.textContent=body.rows[0].title;
            gamedata = body.rows[0];
            income = gamedata["starter_income"];
            funds = gamedata["p1_funds"]; 
            economyInfo.textContent = "income: " + income + "\nfunds: " + funds;
            console.log(body.rows[0]);
        }

    });

    endturnbutton.addEventListener('click', () => endTurn())

    function onClickTerrain(terrain, x, y, type){
        if (selectedUnit != null && selectedUnit != undefined &&movingselectedunit){
            let goalCell = selectedUnitMovableTiles.find(c => c['pos_x'] == x && c['pos_y'] == y);
            console.log(goalCell);
            if (goalCell != undefined){
                selectedUnit.sprite.x = terrain.x;
                selectedUnit.sprite.y = terrain.y;
                selectedUnit.stats.pos_x = x;
                selectedUnit.stats.pos_y = y;
                selectedUnit['stats']['can_move_this_turn'] = false; 
            } else {
                console.log('Out of range');
            }
        } else {
            console.log(type)
            if (type['canprintunits']){
                for (let i = 0; i < type['unitprintlist'].length; i++){
                    let unitTypeID = type['unitprintlist'][i];
                    let unitType = unittypes.find(c => c['id'] == unitTypeID);
                    let printRow = document.createElement('div'); 
                    printRow.textContent = unitType['title'] + ", " + unitType['cost']; 
                    console.log(unitType['title']);
                    let buybutton = document.createElement('button');
                    buybutton.addEventListener('click', () => buyUnit(unitType, x, y, terrain.x, terrain.y));
                    buybutton.textContent = "buy";
                    printRow.append(buybutton);
                    unitproductionmenu.append(printRow);
                }
            }
        }
        selectedUnit = null; 
        movingselectedunit = false;
        clearUnitMenu();
    }

    function buyUnit(unitType, gamex, gamey, mapx, mapy){
        let unitSpriteName = 'red' + unitType['title'] + '.png'
        if (funds >= unitType['cost']){
            funds = funds - unitType['cost'];
            let stats = {'type_id': unitType['id'], 'game_id': gamedata['id'], 'player_id': 1, 'pos_x': gamex, 'pos_y': gamey, 'cur_hp': 10, 
            'capturing': false, 'capture_prog': 0, 'can_move_this_turn': false, 'can_attack_this_turn': false, 'can_capture_this_turn': false}; 
            gameunits.push(stats);
            let newsprite = PIXI.Sprite.from(unitSpriteName);
            newsprite.on('click', (event) => onClickUnit(newsprite, unitType, stats));
            newsprite.eventMode = 'dynamic';
            newsprite.x = mapx;
            newsprite.y = mapy;
            app.stage.addChild(newsprite); 
            economyInfo.textContent = "income: " + income + "\nfunds: " + funds;
        } else {
            console.log('Insufficient funds!');
        }
        let j = unitproductionmenu.children.length - 1; 
        while (j >= 0){
            unitproductionmenu.children[j].remove();
            j = j - 1;
        }
    }

    function terrainBuilder(sprite, spritex, spritey, posx, posy, type){
        sprite.y = spritey;
        sprite.x = spritex;
        sprite.on('click', (event) => onClickTerrain(sprite, posx, posy, type));
        sprite.eventMode = 'dynamic';
        mapterrain.push({'sprite': sprite, 'type': type, 'pos_x': posx, 'pos_y': posy})
        sprite.zIndex = -1;
        app.stage.addChild(sprite);
    }

    function onClickUnit(sprite, type, stats){
        clearUnitMenu();
        let movebutton; 
        let attackButton;
        let capturebutton;
        let statblock; 
        console.log(stats['pos_x']);
        console.log(stats['pos_y']);
        selectedUnit = {'sprite': sprite, 'type': type, 'stats': stats};
        if(attackWithUnit){

        // If the player chooses to attack
            attackUnit(attacking_unit, { sprite, type, stats });

        }
        selectedUnitMovableTiles = new Array();
        selectedUnitAttackableTiles = new Array();
        statblock = document.createElement('p'); 
        statblock.textContent = 'unit type: ' + type['title'] +', hp: ' + stats['cur_hp']
        selectedunitmenu.append(statblock);
        let occupiedTile = mapterrain.find(c => c['pos_x'] == stats['pos_x'] && c['pos_y'] == stats['pos_y']);
        let occupiedTileOwner = gamedata['tile_owners'][stats['pos_y']][stats['pos_x']];
        console.log(occupiedTile); 
        console.log(occupiedTileOwner);

        if (stats['can_move_this_turn']){
            let movebutton = document.createElement('button');
            movebutton.textContent = 'Move';
            for (let i = 0; i < mapterrain.length; i++){
                let dx = mapterrain[i]['pos_x'] - stats['pos_x'];
                let dy = mapterrain[i]['pos_y'] - stats['pos_y'];
                if (dx < 0){
                    dx = dx * -1;
                }
                if (dy < 0){
                    dy = dy * -1;
                }
                let distance = dx + dy;
                if (distance <= selectedUnit.type.speed){
                    selectedUnitMovableTiles.push(mapterrain[i]);
                }
                if (distance >= selectedUnit.type.minrange && distance <= selectedUnit.type.maxrange){
                    selectedUnitAttackableTiles.push(mapterrain[i]);
                }
            }
            movebutton.addEventListener('click', () => moveUnit(sprite, type, stats));            
            selectedunitmenu.append(movebutton);
        }
        if (stats['can_capture_this_turn'] && occupiedTile['type']['capturable'] && (occupiedTileOwner != 1)){
            capturebutton = document.createElement('button');
            capturebutton.textContent = 'Capture';
            capturebutton.addEventListener('click', () => captureTile(occupiedTile, stats['pos_x'], stats['pos_y'])); 
            selectedunitmenu.append(capturebutton);
        }
        if (stats['can_attack_this_turn']){
            attackButton = document.createElement('button');
            attackButton.textContent = 'Attack';
            attackButton.addEventListener('click', () => setAttack(sprite, type, stats)); 
            selectedunitmenu.append(attackButton);
        }
        console.log(selectedUnitMovableTiles);
    }

    function setAttack(sprite, type, stats){
        attacking_unit = sprite;
        attackWithUnit = true;
    }


    function calculateDamage(unit1, unit2) {
        // Simple damage formula: damage = attack_power - armor
        const damageToUnit1 = Math.max(unit2.attack_power - unit1.armor, 0);
        const damageToUnit2 = Math.max(unit1.attack_power - unit2.armor, 0);
    
        return { damageToUnit1, damageToUnit2 };
    }

    function attackUnit(attackingUnit, targetUnit) {
        // Ensure both units exist
        if (!attackingUnit || !targetUnit) {
            console.log('One or both units not found.');
            return;
        }
        if (!isTargetInRange(attackingUnit, targetUnit)) {
        console.log('Target is out of range.');
        return;
        }

        attackWithUnit = false;
        attacking_unit['stats']['can_attack_this_turn'] = false; 
        // Calculate damage for both units
        const { damageToUnit1, damageToUnit2 } = calculateDamage(attackingUnit.stats, targetUnit.stats);
    
        // Apply damage
        attackingUnit.stats.cur_hp -= damageToUnit1;
        targetUnit.stats.cur_hp -= damageToUnit2;
    
        // Check if units are destroyed
        if (attackingUnit.stats.cur_hp <= 0) {
            console.log(`${attackingUnit.type.title} has been destroyed!`);
            // Remove attacking unit from game
            removeUnitFromGame(attackingUnit);
        }
    
        if (targetUnit.stats.cur_hp <= 0) {
            console.log(`${targetUnit.type.title} has been destroyed!`);
            // Remove target unit from game
            removeUnitFromGame(targetUnit);
        }
    
        // Update the game UI and state
        updateUnitStats(attackingUnit);
        updateUnitStats(targetUnit);
    }


    function removeUnitFromGame(unit) {
        // Remove unit sprite from the game
        unit.sprite.parent.removeChild(unit.sprite);
    
        // Remove unit from the game units array
        const index = gameunits.indexOf(unit.stats);
        if (index !== -1) {
            gameunits.splice(index, 1);
        }
    
        clearUnitMenu(); // Optionally clear any selected unit menu
    }
    
    function updateUnitStats(unit) {
        // Update the UI with the current stats of the unit
        console.log(`Updated ${unit.type.title} HP: ${unit.stats.cur_hp}`);

    }
    
    function isTargetInRange(attackingUnit, targetUnit) {
        const dx = Math.abs(attackingUnit.stats.pos_x - targetUnit.stats.pos_x);
        const dy = Math.abs(attackingUnit.stats.pos_y - targetUnit.stats.pos_y);
        const distance = dx + dy;

        return distance >= attackingUnit.type.minrange && distance <= attackingUnit.type.maxrange;
    }




    function moveUnit(){
        movingselectedunit = true;
        stats['capture_prog'] = 0;
        stats['capturing'] = false;
    }

    function captureTile(tile, x, y){
        let stats = selectedUnit['stats'];
        stats['capturing'] = true;
        stats['capture_prog'] = stats['capture_prog'] + stats['cur_hp']; 
        console.log(stats['capture_prog']);
        if (stats['capture_prog'] >= 20){
            let spritex = tile.sprite.x; 
            let spritey = tile.sprite.y; 
            tile.sprite.parent.removeChild(tile.sprite);
            let newspritename = 'red' + tile['type']['title'] + '.png'
            let newsprite = PIXI.Sprite.from(newspritename);
            let oldTileIndex = mapterrain.findIndex(c => c['pos_x'] == x && c['pos_y'] == y); 
            mapterrain.splice(oldTileIndex, 1);
            terrainBuilder(newsprite, spritex, spritey, x, y, tile['type']);
            gamedata['tile_owners'][y][x] = 1;
            if (tile['type']['id'] == 4){
                income = income + 10;
                economyInfo.textContent = "income: " + income + ", funds: " + funds;
            }
            stats['capture_prog'] = 0;
            stats['capturing'] = false;
        }
        stats['can_move_this_turn'] = false;
        stats['can_attack_this_turn'] = false;
        clearUnitMenu();
    }

    function clearUnitMenu(){
        let i = selectedunitmenu.children.length - 1; 
        while (i >= 0){
            selectedunitmenu.children[i].remove();
            i = i - 1;
        }
    }

    function endTurn(){
        for (let i = 0; i < gameunits.length; i++){
            gameunits[i]['can_move_this_turn'] = true;
            gameunits[i]['can_attack_this_turn'] = true;
            gameunits[i]['can_capture_this_turn'] = true;
        }
        funds = funds + income; 
        economyInfo.textContent = "income: " + income + ", funds: " + funds;
        clearUnitMenu();
    }
</script>

<script>
    
    
  </script>
</html>