<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Gamescreen</title>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <div class="navbar">
        <div class="navbar-left">
        <a href="/">Home</a>
        <a href="/gamelist">Game List</a>
        <a href="/creategame">Create Game</a>
        <a href="/lobby">Lobby</a>
        <a href="/loginPage">Login</a>
        <a href="/settings">Settings</a>
        </div>
        <div class="navbar-right" id="loggedinUser">Not logged in</div>
    </div>
    <h1 id="gametitle"></h1>

    <p>Welcome to the game!</p>

    <p id="maptitle"></p>
    <div id="economyInfo"></div>
    <div id="user_id"></div>
    <button id="endturnbutton">End Turn</button>
    <button id="forfeit">Forfeit</button>

    <div style="float:right">

        <div id="commanderinfo"></div>

        <div id="selectedunitmenu" style="float:left"></div>

        <div id="unitproductionmenu" style="float:left"></div>

    </div>

</body>

<script src="https://pixijs.download/release/pixi.js"></script>

<script type="module">  
    //todo add gameunit rendering from past game state. //rest the unit table. drop all units created in a game when  the game is over(do this server side ) 
    let gametitle = document.getElementById("gametitle");
    let unitproductionmenu = document.getElementById("unitproductionmenu");
    let economyInfo = document.getElementById("economyInfo");
    let selectedunitmenu = document.getElementById("selectedunitmenu");
    let endturnbutton = document.getElementById("endturnbutton");
    let forfeitbutton = document.getElementById("forfeit");
    let commanderinfo = document.getElementById("commanderinfo");

    let commanderImage;
    let commanderDesc;
    let commanderName;

    let opCommanderImage;
    let opCommanderDesc;
    let opCommanderName;

    let gamedata;
    let unittypes;
    let terraintypes;
    let gameunits;
    let mapdata;
    let querystring = window.location.href.slice(window.location.href.indexOf('?'));
    let selectedUnit;
    let selectedUnitMovableTiles;
    let selectedUnitAttackableTiles;
    let income; 
    let funds; 
    let movingselectedunit = false;
    let attackWithUnit = false;
    let attacking_unit;
    let fogEnabled;
    let fogLayer; 
    let visibleTiles;
    let isPlayer1Turn;
    let currentPlayerId;
    let commanders;
    let curCommander;
    let opCommander;
    let app = new PIXI.Application();
    let mapterrain = new Array();
    let highlightLayer = new Array();
    function showUserInfo() {
        const userInfoDiv = document.getElementById('user_id');
        const userId = getUserId();
    
        if (userId) {
            console.log('User ID found: ', userId); // Debugging log
            userInfoDiv.textContent = 'Logged in as User ID: ' + userId;
        } else {
            console.log('No User ID found'); // Debugging log
            userInfoDiv.textContent = 'User not logged in';
        }
    }
    
    function getUserId() {
        // Example: Retrieve user ID from a cookie, local storage, or a server API call
        const userIdFromCookies = getCookie('userId');
        console.log('User ID from Cookies: ', userIdFromCookies); // Debugging log
        if (userIdFromCookies) {
            return userIdFromCookies;
        }
    
        const userIdFromLocalStorage = localStorage.getItem('userId');
        console.log('User ID from Local Storage: ', userIdFromLocalStorage); // Debugging log
        if (userIdFromLocalStorage) {
            return userIdFromLocalStorage;
        }
    
        return null; 
    }
    
    // Helper function to get a cookie by name
    function getCookie(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) {
            const cookieValue = parts.pop().split(';').shift();
            console.log('Cookie found:', name, '=', cookieValue); // Debugging log
            return cookieValue;
        }
        console.log('Cookie not found:', name); // Debugging log
        return null;
    }

    async function initGame() {
        // Fetch map data
        const mapResponse = await fetch("/map" + querystring, { method: "GET" });
        const mapBody = await mapResponse.json();
        if (mapBody.rows.length <= 0) {
            console.log("No game found");
        } else {
            mapdata = mapBody.rows[0];
            maptitle.textContent = mapdata.title;
        }

        let canvasWidth = mapdata.width * 16;
        let canvasHeight = mapdata.height * 16;
        // Initialize PIXI app without passing options directly
        
        await app.init({ width: canvasWidth, height: canvasHeight});
    
        // Append the canvas to the body using `canvas` instead of `view`
        document.body.appendChild(app.canvas);
    
        console.log(querystring);
    
        // Load assets
        const assetPromises = [
            PIXI.Assets.load('neutralfactory.png'),
            PIXI.Assets.load('neutralhq.png'),
            PIXI.Assets.load('redfactory.png'),
            PIXI.Assets.load('redhq.png'),
            PIXI.Assets.load('bluefactory.png'),
            PIXI.Assets.load('bluehq.png'),
            PIXI.Assets.load('plains.png'),
            PIXI.Assets.load('mountain.png'),
            PIXI.Assets.load('forest.png'),
            PIXI.Assets.load('neutralairport.png'),
            PIXI.Assets.load('redairport.png'),
            PIXI.Assets.load('blueairport.png'),
            PIXI.Assets.load('neutralsettlement.png'),
            PIXI.Assets.load('redsettlement.png'),
            PIXI.Assets.load('bluesettlement.png'),
            PIXI.Assets.load('redinfantry.png'),
            PIXI.Assets.load('blueinfantry.png'),
            PIXI.Assets.load('blueantiair.png'),          
            PIXI.Assets.load('redantiair.png'),           
            PIXI.Assets.load('neutralantiair.png'),
            PIXI.Assets.load('blueartillery.png'),
            PIXI.Assets.load('redartillery.png'),
            PIXI.Assets.load('neutralartillery.png'),
            PIXI.Assets.load('bluebomber.png'),
            PIXI.Assets.load('redbomber.png'),
            PIXI.Assets.load('neutralbomber.png'),
            PIXI.Assets.load('bluefighter.png'),
            PIXI.Assets.load('redfighter.png'),
            PIXI.Assets.load('neutralfighter.png'),
            PIXI.Assets.load('blueheavytank.png'),
            PIXI.Assets.load('redheavytank.png'),
            PIXI.Assets.load('neutralheavytank.png'),
            PIXI.Assets.load('bluehelicopter.png'),
            PIXI.Assets.load('redhelicopter.png'),
            PIXI.Assets.load('neutralhelicopter.png'),
            PIXI.Assets.load('bluelighttank.png'),
            PIXI.Assets.load('redlighttank.png'),
            PIXI.Assets.load('neutrallighttank.png'),
            PIXI.Assets.load('bluemechinfantry.png'),
            PIXI.Assets.load('redmechinfantry.png'),
            PIXI.Assets.load('neutralmechinfantry.png'),
            PIXI.Assets.load('bluerecon.png'),
            PIXI.Assets.load('redrecon.png'),
            PIXI.Assets.load('neutralrecon.png'),
            PIXI.Assets.load('bluerocketarty.png'),
            PIXI.Assets.load('redrocketarty.png'),
            PIXI.Assets.load('neutralrocketarty.png'),
            PIXI.Assets.load('fog.png'),
            PIXI.Assets.load('movehighlight.png'),
            PIXI.Assets.load('attackhighlight.png')
        ];
    
        await Promise.all(assetPromises);
    
        // The rest of your initialization and fetch logic remains the same
        // Function to display the current user's information

        // Fetch terrain types
        const terrainResponse = await fetch("/terraintypes", { method: "GET" });
        const terrainBody = await terrainResponse.json();
        terraintypes = terrainBody.rows;

        // Fetch unit types
        const unitResponse = await fetch("/unittypes", { method: "GET" });
        const unitBody = await unitResponse.json();
        unittypes = unitBody.rows;

        const commandersResponse = await fetch("/commanders", {method: "GET"});
        const commandersBody = await commandersResponse.json();
        commanders = commandersBody.rows;

        // Fetch game units
        const gameUnitsResponse = await fetch("/gameunits" + querystring, { method: "GET" });
        const gameUnitsBody = await gameUnitsResponse.json();
        gameunits = gameUnitsBody.rows;

        const gameStateResponse = await fetch("/game" + querystring, { method: "GET" });
        const gameStateBody = await gameStateResponse.json();
        if (gameStateBody.rows.length <= 0) {
            console.log("No game found");
        } else {
            initializeGameState(gameStateBody.rows[0], app);
            showUserInfo();
        }

        
        console.log("p1_commander: " + gamedata['p1_commander']);
        console.log("p2_commander: " + gamedata['p2_commander']);

        buildMap(mapdata);

        if(isPlayer1Turn){
            curCommander = commanders.find(c => c.id == gamedata['p1_commander']);
            opCommander = commanders.find(c => c.id == gamedata['p2_commander']);
        } else {
            curCommander = commanders.find(c => c.id == gamedata['p2_commander']);
            opCommander = commanders.find(c => c.id == gamedata['p1_commander']);
        }

        commanderImage = document.createElement("img");
        commanderImage.src = curCommander.title + ".png";
        commanderImage.alt = curCommander.backstory; 

        commanderName = document.createElement("p");
        commanderName.textContent = "Your commander: " + curCommander['readable_title'];

        commanderDesc = document.createElement("p");
        commanderDesc.textContent = curCommander['effect_description'];

        opCommanderImage = document.createElement("img");
        opCommanderImage.src = opCommander.title + ".png";
        opCommanderImage.alt = opCommander.backstory; 

        opCommanderName = document.createElement("p");
        opCommanderName.textContent = "Opponent commander: " + opCommander['readable_title'];

        opCommanderDesc = document.createElement("p");
        opCommanderDesc.textContent = opCommander['effect_description'];



        commanderinfo.append(commanderName);
        commanderinfo.append(commanderImage);
        commanderinfo.append(commanderDesc);
        commanderinfo.append(opCommanderName);
        commanderinfo.append(opCommanderImage);
        commanderinfo.append(opCommanderDesc);

        forfeitbutton.addEventListener("click", quitGame);
    }

    function buildMap(mapdata) {
        for (let i = 0; i < mapdata.terrain.length; i++) {
            let row = mapdata.terrain[i];
            let ownerRow = gamedata['tile_owners'][i];
            let y = i * 16;
            for (let j = 0; j < row.length; j++) {
                let x = j * 16;
                let type = row[j];
                let typeData = terraintypes[type - 1];
                let owner = ownerRow[j];
                let spriteName; 
                if (typeData['capturable']) {
                    if (owner == 0) {
                        spriteName = 'neutral' + typeData['title'] + '.png';
                    } else if (owner == 1) {
                        spriteName = 'red' + typeData['title'] + '.png';
                    } else {
                        spriteName = 'blue' + typeData['title'] + '.png';
                    }
                } else {
                    spriteName = typeData['title'] + '.png';
                }
                let sprite = PIXI.Sprite.from(spriteName);
                terrainBuilder(sprite, x, y, j, i, typeData);
            }
        }
        if (fogEnabled) {
            drawFog(app);
        }
    }
    function drawUnits() {
        // Loop through all game units and place them on the map
        for (let i = 0; i < gameunits.length; i++) {
            let unit = gameunits[i];
            let unitType = unittypes.find(type => type.id === unit.type_id);
            
            // Determine the sprite name based on the player's color (red or blue)
            let spriteName = (unit.player_id === gamedata.p1_id ? 'red' : 'blue') + unitType.title + '.png';
            
            // Create the sprite for the unit
            let unitSprite = PIXI.Sprite.from(spriteName);
            
            // Position the sprite on the map
            unitSprite.x = unit.pos_x * 16; // Assuming each tile is 16x16 pixels
            unitSprite.y = unit.pos_y * 16;
            
            // Set event handler for clicking the unit
            console.log("stats",unit,typeof unit.cur_hp)
            unitSprite.on('click', (event) => onClickUnit(unitSprite, unitType, unit));
            unitSprite.eventMode = 'dynamic';
            
            // Add the sprite to the PIXI application stage
            app.stage.addChild(unitSprite);
            
            // Store the sprite in the unit data for future reference (e.g., moving the unit)
            unit.sprite = unitSprite;
        }
    }
    function initializeGameState(gameState, app) {
        fogLayer = new Array();
        gametitle.textContent = gameState.title;
        gamedata = gameState;
        currentPlayerId = getCookie("userId"); 
        
        if (gamedata["turn"] % 2 === 1) {
            isPlayer1Turn = true;
            income = gamedata.p1_income;
            funds = gamedata.p1_funds;
        } else {
            isPlayer1Turn = false;
            income = gamedata.p2_income;
            funds = gamedata.p2_funds;
        }
        fogEnabled = gamedata['fog'];
        economyInfo.textContent = "income: " + income + "\nfunds: " + funds;
        // If it's not the player's turn, disable actions
        endturnbutton.style.display = 'block';
        if ((isPlayer1Turn && parseInt(currentPlayerId) !== gamedata.p1_id) || (!isPlayer1Turn && parseInt(currentPlayerId) !== gamedata.p2_id)) {
            endturnbutton.style.display = 'none';  // Hide the "End Turn" button
            console.log(isPlayer1Turn);
            console.log(gamedata.p2_id);
            console.log(currentPlayerId);
            disableActions();  // Disable unit selection, movement, etc.
        }
        drawUnits();
    }

    initGame();

    function disableActions() {
        // Disable unit selection, movement, and attacks
        document.querySelectorAll('button').forEach(button => {
            button.disabled = true;
        });
        document.querySelectorAll('canvas').forEach(canvas => {
            canvas.style.pointerEvents = 'none';
        });
    }

    function drawFog(){
        let visibleTiles = new Array(); 
        for (let i = 0; i < gamedata['tile_owners'].length; i++){
            let ownerRow = gamedata['tile_owners'][i];
            for (let j = 0; j < ownerRow.length; j++){
                if ((parseInt(currentPlayerId) === gamedata.p1_id && ownerRow[j] === 1) || (parseInt(currentPlayerId) === gamedata.p2_id && ownerRow[j] === 2)) {
                    visibleTiles.push({'x': j, 'y': i});
                }
            }
        }
        for (let k = 0; k < gameunits.length; k++){
            let unit = gameunits[k];
            if ((parseInt(currentPlayerId) === gamedata.p1_id && isPlayer1Turn && unit.player_id === gamedata.p1_id) || (parseInt(currentPlayerId) === gamedata.p2_id && !isPlayer1Turn && unit.player_id === gamedata.p2_id)) {
                let unitStats = unittypes[unit['type_id'] - 1]; 
                for (let i = 0; i < mapterrain.length; i++){
                    let dx = mapterrain[i]['pos_x'] - unit['pos_x'];
                    let dy = mapterrain[i]['pos_y'] - unit['pos_y'];
                    let distance = Math.abs(dx) + Math.abs(dy);
                    if (distance <= unitStats['sightrange']){
                        let extantTile = visibleTiles.find(c => c['x'] == mapterrain[i]['pos_x'] && c['y'] == mapterrain[i]['pos_y']);
                        if (extantTile === undefined){
                            visibleTiles.push({'x': mapterrain[i]['pos_x'], 'y': mapterrain[i]['pos_y']});
                        }
                    }
                }
            }
        }
        fogLayer.forEach(sprite => sprite.parent.removeChild(sprite));
        fogLayer = new Array();
        mapterrain.forEach(mapTile => {
            let visibleTile = visibleTiles.find(c => c['x'] == mapTile['pos_x'] && c['y'] == mapTile['pos_y']);
            if (visibleTile === undefined){
                let fogSprite = PIXI.Sprite.from('fog.png'); 
                fogSprite.x = mapTile['pos_x'] * 16;
                fogSprite.y = mapTile['pos_y'] * 16;
                fogSprite.zIndex = 2;
                app.stage.addChild(fogSprite);
                fogLayer.push(fogSprite);
            }
        });
    }

    function onClickTerrain(terrain, x, y, type) {
        clearHighlight();
        if (selectedUnit && movingselectedunit) {
            let goalCell = selectedUnitMovableTiles.find(c => c['pos_x'] == x && c['pos_y'] == y);
            if (goalCell) {
                selectedUnit.sprite.x = terrain.x;
                selectedUnit.sprite.y = terrain.y;
                selectedUnit.stats.pos_x = x;
                selectedUnit.stats.pos_y = y;
                selectedUnit['stats']['can_move_this_turn'] = false; 
                if (fogEnabled) {
                    drawFog();
                }
                updateUnitStats(selectedUnit);
            } else {
                console.log('Out of range');
            }
        } else {
            // Check if terrain is owned by the current player
            const terrainOwner = gamedata.tile_owners[y][x]; // Assuming tile_owners is a 2D array
    
            if ((isPlayer1Turn && terrainOwner === 1 && parseInt(currentPlayerId) === gamedata.p1_id) ||
                (!isPlayer1Turn && terrainOwner === 2 && parseInt(currentPlayerId) === gamedata.p2_id)) {
                
                if (type['canprintunits']) {
                    type['unitprintlist'].forEach(unitTypeID => {
                        let unitType = unittypes.find(c => c['id'] == unitTypeID);
                        if (curCommander.id == 2 && (unitTypeID == 1 || unitTypeID == 2)){
                            unitType['cost'] = 0;
                        }
                        let printRow = document.createElement('div');
                        printRow.textContent = unitType['title'] + ", " + unitType['cost'];
                        let buybutton = document.createElement('button');
                        buybutton.addEventListener('click', () => buyUnit(unitType, x, y, terrain.x, terrain.y));
                        buybutton.textContent = "buy";
                        printRow.append(buybutton);
                        unitproductionmenu.append(printRow);
                    });
                }
            } else {
                console.log("Terrain not owned by current player");
            }
        }
        selectedUnit = null; 
        movingselectedunit = false;
        clearUnitMenu();
    }

    function buyUnit(unitType, gamex, gamey, mapx, mapy) {
        let unitSpriteName = (isPlayer1Turn ? 'red' : 'blue') + unitType['title'] + '.png';
    
        if (funds >= unitType['cost']) {
            funds -= unitType['cost'];
            if (isPlayer1Turn) {
                gamedata.p1_funds = funds;
            } else {
                gamedata.p2_funds = funds;
            }
    
            let unitData = {
                type_id: unitType['id'],
                game_id: gamedata['id'],
                player_id: isPlayer1Turn ? gamedata.p1_id : gamedata.p2_id,
                pos_x: gamex,
                pos_y: gamey,
                isP1: isPlayer1Turn
            };
            fetch("/add/unit", {
                method: "POST",
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(unitData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.unit_id) {
                    let stats = {
                        id: data.unit_id,
                        type_id: unitType['id'],
                        game_id: gamedata['id'],
                        player_id: unitData.player_id,
                        pos_x: gamex,
                        pos_y: gamey,
                        cur_hp: 10,
                        capturing: false,
                        capture_prog: 0,
                        can_move_this_turn: false,
                        can_attack_this_turn: false,
                        can_capture_this_turn: false
                    };
                    gameunits.push(stats);
    
                    let newsprite = PIXI.Sprite.from(unitSpriteName);
                    newsprite.on('click', (event) => onClickUnit(newsprite, unitType, stats));
                    newsprite.eventMode = 'dynamic';
                    newsprite.x = mapx;
                    newsprite.y = mapy;
                    app.stage.addChild(newsprite);
    
                    economyInfo.textContent = "income: " + income + "\nfunds: " + funds;
                    if (fogEnabled) {
                        drawFog();
                    }
                } else {
                    console.log('Failed to add unit to the server.');
                }
            })
            .catch(error => {
                console.error("Error adding unit:", error);
            });
        } else {
            console.log('Insufficient funds!');
        }
    
        let j = unitproductionmenu.children.length - 1;
        while (j >= 0) {
            unitproductionmenu.children[j].remove();
            j--;
        }
    

    }

    function terrainBuilder(sprite, spritex, spritey, posx, posy, type){
        sprite.y = spritey;
        sprite.x = spritex;
        sprite.on('click', (event) => onClickTerrain(sprite, posx, posy, type));
        sprite.eventMode = 'dynamic';
        mapterrain.push({'sprite': sprite, 'type': type, 'pos_x': posx, 'pos_y': posy})
        sprite.zIndex = -1;
        app.stage.addChild(sprite);
    }

    function onClickUnit(sprite, type, stats) {
        clearHighlight();
        console.log("unit", sprite, stats);
        clearUnitMenu();
        selectedUnit = { 'sprite': sprite, 'type': type, 'stats': stats };
    
        // Check if the current player owns the unit
        const currentPlayerOwnsUnit = 
            (parseInt(currentPlayerId) === gamedata.p1_id && isPlayer1Turn && stats.player_id === gamedata.p1_id) ||
            (parseInt(currentPlayerId) === gamedata.p2_id && !isPlayer1Turn && stats.player_id === gamedata.p2_id);
    
        // Only allow attack with units owned by the current player
        if (attackWithUnit) {
            console.log('Attacking unit:', selectedUnit, 'Stats:', selectedUnit.stats);
            attackUnit(attacking_unit, selectedUnit);
        }
    
        // Initialize movable and attackable tile arrays
        selectedUnitMovableTiles = [];
        selectedUnitAttackableTiles = [];

        for (let i = 0; i < mapterrain.length; i++) {
            let speed = selectedUnit.type.speed;
            let maxrange = selectedUnit.type.maxrange;
            if (curCommander.id == 2 && (selectedUnit.type.id == 1 || selectedUnit.type.id == 2)){
                speed += 1;
            } 
            if (curCommander.id == 4 && (selectedUnit.type.id == 9 || selectedUnit.type.id == 10 || selectedUnit.type.id == 11)){
                speed += 2;
            }
            if (curCommander.id == 1 && (selectedUnit.type.id == 6 || selectedUnit.type.id == 7)){
                maxrange += 1;
            }
            let dx = mapterrain[i]['pos_x'] - stats['pos_x'];
            let dy = mapterrain[i]['pos_y'] - stats['pos_y'];
            let distance = Math.abs(dx) + Math.abs(dy);

            if (distance > 0 && distance <= speed) {
                selectedUnitMovableTiles.push(mapterrain[i]); 
            }
            if (distance > selectedUnit.type.minrange && distance <= maxrange) {
                selectedUnitAttackableTiles.push(mapterrain[i]);
            }
        }
    
        // Display unit stats
        let statblock = document.createElement('p');
        statblock.textContent = 'unit type: ' + type['title'] + ', hp: ' + stats['cur_hp'];
        selectedunitmenu.append(statblock);
    
        let occupiedTile = mapterrain.find(c => c['pos_x'] == stats['pos_x'] && c['pos_y'] == stats['pos_y']);
        let occupiedTileOwner = gamedata['tile_owners'][stats['pos_y']][stats['pos_x']];
    
        // Allow movement and capturing only if the player owns the unit
        if (currentPlayerOwnsUnit) {
            // Handle movement
            if (stats['can_move_this_turn']) {
                let movebutton = document.createElement('button');
                movebutton.textContent = 'Move';
    
                for (let i = 0; i < selectedUnitMovableTiles.length; i++){
                    let movehighlight = PIXI.Sprite.from('movehighlight.png');
                    movehighlight.zIndex = 2; 
                    movehighlight.x = selectedUnitMovableTiles[i].sprite.x + 6;
                    movehighlight.y = selectedUnitMovableTiles[i].sprite.y + 6;
                    app.stage.addChild(movehighlight);
                    highlightLayer.push(movehighlight);
                }
    
                movebutton.addEventListener('click', () => moveUnit(sprite, type, stats));
                selectedunitmenu.append(movebutton);
            }
    
            // Handle capturing
            if (stats['can_capture_this_turn'] && occupiedTile['type']['capturable'] && (occupiedTileOwner != (isPlayer1Turn ? 1 : 2))) {
                let capturebutton = document.createElement('button');
                capturebutton.textContent = 'Capture';
                capturebutton.addEventListener('click', () => captureTile(occupiedTile, stats['pos_x'], stats['pos_y']));
                selectedunitmenu.append(capturebutton);
            }
        
            // Allow attacking if the unit belongs to the player and has attack abilities
            if (stats['can_attack_this_turn']) {
                let attackButton = document.createElement('button');
                attackButton.textContent = 'Attack';
                attackButton.addEventListener('click', () => setAttack(sprite, type, stats));
                selectedunitmenu.append(attackButton);
            }
        }
    }
    
    function calculateDamage(unit1, unit2) {
        console.log("unit1",unit1);
        console.log("unit2",unit2);
        let u1stats = unit1.stats;
        let u1hp = u1stats.cur_hp;

        let u1dam = unit1.type['attack_power'];
        let u1armor = unit1.type['armor'];
        let u1ap = unit1.type['armor_pierce'];
        let u1sa = unit1.type['strong_against'];
        let u1wa = unit1.type['weak_against'];
        let u1totalDam;

        if (curCommander.id == 1 && (unit1.type.id == 6 || unit1.type.id == 7)){
            u1dam += 1;
            u1ap += 1;
        }
        if (curCommander.id == 2 && (unit1.type.id == 1 || unit1.type.id == 2)){
            u1ap = u1ap * 2; 
        }
        if (curCommander.id == 3 && (unit1.type.id == 4 || unit1.type.id == 5)){
            u1armor += 2;
            u1dam += 2;
        }
        if (curCommander.id == 4 && (unit1.type.id == 9 || unit1.type.id == 10 || unit1.type.id == 11)){
            u1dam += 1;
        }
        
        let u1row = mapdata.terrain[u1stats.pos_y];
        let u1tiletype = u1row[u1stats.pos_x];
        let u1tileData = terraintypes.find(c => c.id == u1tiletype);
        let u1cover = u1tileData.cover; 

        let u2stats = unit2.stats; 
        let u2hp = u2stats.cur_hp;

        let u2dam = unit2.type['attack_power'];
        let u2armor = unit2.type['armor'];
        let u2ap = unit2.type['armor_pierce'];
        let u2sa = unit2.type['strong_against'];
        let u2wa = unit2.type['weak_against'];
        let u2totalDam;

        if (opCommander.id == 1 && (unit2.type.id == 6 || unit2.type.id == 7)){
            u2dam += 1;
            u2ap += 1;
        }
        if (opCommander.id == 2 && (unit2.type.id == 1 || unit2.type.id == 2)){
            u2ap = u2ap * 2; 
        }
        if (opCommander.id == 3 && (unit2.type.id == 4 || unit2.type.id == 5)){
            u2armor += 2;
            u2dam += 2;
        }
        if (opCommander.id == 4 && (unit2.type.id == 9 || unit2.type.id == 10 || unit2.type.id == 11)){
            u2dam += 1;
        }

        let u2row = mapdata.terrain[u2stats.pos_y];
        let u2tiletype = u2row[u2stats.pos_x];
        let u2tileData = terraintypes.find(c => c.id == u2tiletype);
        let u2cover = u1tileData.cover; 

        let u2armorAfterAP = u2armor - u1ap;

        if (u2armorAfterAP < 0){
            u2armorAfterAP = 0;
        }

        
        u2totalDam = (u1dam - (u2cover + u2armorAfterAP)) * (u1hp / 10);

        if (u1sa.includes(unit2.type.id)){
            u2totalDam = u2totalDam * 2; 
        }
        if (u1wa.includes(unit2.type.id)){
            u2totalDam = u2totalDam / 2;
        }

        let u1armorAfterAP = u1armor - u2ap;

        if (u1armorAfterAP < 0){
            u1armorAfterAP = 0;
        }

        u1totalDam = (u2dam - (u1cover + u1armorAfterAP)) * ((u2hp - u2totalDam) / 10);

        if (u2sa.includes(unit1.type.id)){
            u1totalDam = u1totalDam * 2; 
        }
        if (u2wa.includes(unit1.type.id)){
            u1totalDam = u1totalDam / 2;
        }

        if (!isTargetInRange(unit2, unit1)){
            u1totalDam = 0;
        }

        const damageToUnit1 = Math.floor(u1totalDam);
        const damageToUnit2 = Math.floor(u2totalDam);
    
        return { damageToUnit1, damageToUnit2 };
    }
    
    function attackUnit(attackingUnit, targetUnit) {
        console.log('Attacking unit:', attackingUnit, 'Stats:', attackingUnit.stats);
        
        if (!attackingUnit || !targetUnit) {
            attackWithUnit = false;
            console.log('One or both units not found.');
            return;
        }
    
        if (!isTargetInRange(attackingUnit, targetUnit)) {
            attackWithUnit = false;
            console.log('Target is out of range.');
            return;
        }
    
        if (attackingUnit.stats.player_id === targetUnit.stats.player_id) {
            attackWithUnit = false;
            console.log('Cannot attack units of the same team.');
            return;
        }
    
        attackWithUnit = false;
        attacking_unit['stats']['can_attack_this_turn'] = false;
    
        const { damageToUnit1, damageToUnit2 } = calculateDamage(attackingUnit, targetUnit);
    
        attackingUnit.stats.cur_hp -= damageToUnit1;
        targetUnit.stats.cur_hp -= damageToUnit2;
        console.log("health ", attackingUnit.stats.cur_hp , targetUnit.stats.cur_hp)
        if (attackingUnit.stats.cur_hp <= 0) {
            console.log(`${attackingUnit.type.title} has been destroyed!`);
            removeUnitFromGame(attackingUnit);
        }
    
        if (targetUnit.stats.cur_hp <= 0) {
            console.log(`${targetUnit.type.title} has been destroyed!`);
            removeUnitFromGame(targetUnit);
        }
    
        updateUnitStats(attackingUnit);
        updateUnitStats(targetUnit);
    }
    

    function setAttack(sprite, type, stats){
        clearHighlight();
        for (let i = 0; i < selectedUnitAttackableTiles.length; i++){
            let curTile = selectedUnitAttackableTiles[i]; 
            let atkHighlight = PIXI.Sprite.from('attackhighlight.png');
            atkHighlight.zIndex = 2; 
            atkHighlight.x = curTile.sprite.x + 6;
            atkHighlight.y = curTile.sprite.y + 6;
            app.stage.addChild(atkHighlight);
            highlightLayer.push(atkHighlight);
        }
        console.log("setting attacking stats:", stats);
        attacking_unit = {'sprite': sprite, 'type': type, 'stats': stats};
        attackWithUnit = true;
    }


    function removeUnitFromGame(unit) {
        unit.sprite.parent.removeChild(unit.sprite);
        const index = gameunits.indexOf(unit.stats);
        if (index !== -1) {
            gameunits.splice(index, 1);
        }
        fetch("/deleteunit", {
            method: "POST",
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                id: unit.stats.id
            })
        }).then(response => {console.log(response.status);})
        clearUnitMenu();
    }
    
    function updateUnitStats(unit) {
        console.log(`Updated:`,unit.type.title, "HP:", unit.stats.cur_hp);
    
        // Create an object with only the relevant stats
        const relevantStats = {
            unit_id: unit.stats.id,
            cur_hp: unit.stats.cur_hp,
            capturing: unit.stats.capturing,
            capture_prog: unit.stats.capture_prog,
            can_capture_this_turn: unit.stats.can_capture_this_turn,
            can_move_this_turn: unit.stats.can_move_this_turn,
            can_attack_this_turn: unit.stats.can_attack_this_turn,
            pos_x: unit.stats.pos_x,
            pos_y: unit.stats.pos_y
        };
    
        fetch("/update/unit", {
            method: "POST",
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(relevantStats)
        })
        .then(response => response.json())
        .then(data => {
                console.log("Unit stats updated successfully");
        })
        .catch(error => {
            console.error("Error updating unit stats:", error);
        });
    }

    
    function isTargetInRange(attackingUnit, targetUnit) {
        console.log('Attacking unit:', attackingUnit, 'Stats:', attackingUnit.stats);
        const dx = Math.abs(attackingUnit.stats.pos_x - targetUnit.stats.pos_x);
        const dy = Math.abs(attackingUnit.stats.pos_y - targetUnit.stats.pos_y);
        const distance = dx + dy;

        return distance > attackingUnit.type.minrange && distance <= attackingUnit.type.maxrange;
    }

    function moveUnit(sprite, type, stats) {
        movingselectedunit = true;
        stats['capture_prog'] = 0;
        stats['capturing'] = false;

    }

    function captureTile(tile, x, y){
        clearHighlight();
        let stats = selectedUnit['stats'];
        stats['capturing'] = true;
        stats['capture_prog'] += stats['cur_hp']; 
        console.log(stats['capture_prog']);
        if (stats['capture_prog'] >= 20){
            tile.sprite.parent.removeChild(tile.sprite);
            let newspritename = (isPlayer1Turn ? 'red' : 'blue') + tile['type']['title'] + '.png';
            let newsprite = PIXI.Sprite.from(newspritename);
            let oldTileIndex = mapterrain.findIndex(c => c['pos_x'] == x && c['pos_y'] == y); 
            mapterrain.splice(oldTileIndex, 1);
            terrainBuilder(newsprite, tile.sprite.x, tile.sprite.y, x, y, tile['type']);
            gamedata['tile_owners'][y][x] = isPlayer1Turn ? 1 : 2;
            if (tile['type']['id'] == 4){
                income += 10;
                economyInfo.textContent = "income: " + income + ", funds: " + funds;
            } else if (tile['type']['id'] == 1) {
                winGame();
            }
            stats['capture_prog'] = 0;
            stats['capturing'] = false;
        }
        stats['can_move_this_turn'] = false;
        stats['can_attack_this_turn'] = false;
        stats['can_capture_this_turn'] = false;
        updateUnitStats(selectedUnit);
        clearUnitMenu();
    }

    function clearUnitMenu(){
        while (selectedunitmenu.firstChild) {
            selectedunitmenu.removeChild(selectedunitmenu.firstChild);
        }
    }

    function updateGame() {
        console.log(gamedata.turn);
    
        const player1Units = gameunits.filter(unit => unit.player_id === 1).map(unit => unit.id);
        const player2Units = gameunits.filter(unit => unit.player_id === 2).map(unit => unit.id);
    
        const gameStateUpdate = {
            p1_units: isPlayer1Turn ? player1Units : gamedata.p1_units,
            p2_units: !isPlayer1Turn ? player2Units : gamedata.p2_units,
            p1_funds: isPlayer1Turn ? funds : gamedata.p1_funds,
            p2_funds: !isPlayer1Turn ? funds : gamedata.p2_funds,
            p1_income: isPlayer1Turn ? income : gamedata.p1_income,
            p2_income: !isPlayer1Turn ? income : gamedata.p2_income,
            tile_owners: gamedata['tile_owners'],
            fog: fogEnabled,
            turn: gamedata.turn + 1,

        };

        console.log(gameStateUpdate.tile_owners);
    
        fetch("/updateGameState" + querystring, {
            method: "POST",
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(gameStateUpdate)
        })
        .then(response => {
            if (response.ok) {
                console.log("Game state updated successfully.");
            } else {
                console.log("Failed to update game state.");
            }
        })
        .catch(error => {
            console.error("Error updating game state:", error);
        });
    }
    
    endturnbutton.addEventListener("click", endTurn);
    function endTurn() {
        // Disable the End Turn button to prevent multiple submissions
        endturnbutton.disabled = true;
    
        // Reset unit actions for the next turn
        for (let i = 0; i < gameunits.length; i++) {
            gameunits[i]['can_move_this_turn'] = true;
            gameunits[i]['can_attack_this_turn'] = true;
            gameunits[i]['can_capture_this_turn'] = true;
        }
    
        // Update funds and display the updated economy info
        funds += income;
        economyInfo.textContent = "income: " + income + ", funds: " + funds;
    
        // Clear the selected unit menu
        clearUnitMenu();
    
        // Update the game state on the server
        updateGame();
    
        // Determine whose turn is next and update the visuals accordingly
        if (gamedata["turn"] % 2 === 0) {
            isPlayer1Turn = true;
            income = gamedata.p1_income;
            funds = gamedata.p1_funds;
            gametitle.textContent = "Player 1's Turn";
        } else {
            isPlayer1Turn = false;
            income = gamedata.p2_income;
            funds = gamedata.p2_funds;
            gametitle.textContent = "Player 2's Turn";
        }
    
        // Check if it's the current player's turn; if not, hide the End Turn button
        if ((isPlayer1Turn && parseInt(currentPlayerId) !== gamedata.p1_id) || (!isPlayer1Turn && currentPlayerId !== gamedata.p2_id)) {
            endturnbutton.style.display = 'none'; // Hide the "End Turn" button
            disableActions();  // Disable unit selection, movement, etc.
        } else {
            endturnbutton.style.display = 'inline-block'; // Show the "End Turn" button
            endturnbutton.disabled = false; // Enable the "End Turn" button for the new turn
        }
    }

    function clearHighlight(){
        console.log('clearing highlight');
        highlightLayer.forEach(sprite => sprite.parent.removeChild(sprite));
        highlightLayer = new Array();
    }

    function winGame(){
        console.log("winning game");
        let gameId = gamedata.id; 
        let winner;
        if (isPlayer1Turn) {
            winner = gamedata.p1_id;
        } else {
            winner = gamedata.p2_id;
        }

        fetch("/finishgame", { 
            method: "POST",
            headers : {"Content-Type": "application/json"},
            body: JSON.stringify({"gameId": gameId, "winner": winner})
        }).then(response =>{
            console.log(response.status);
            if (response.status == 200){
                window.location.href = "https://basicwars.fly.dev/winscreen";
            }
        })
        
    }

    function quitGame(){
        console.log("quitting game");
        let gameId = gamedata.id; 
        let userId = getUserId();;
        if (userId == gamedata.p1_id) {
            winner = gamedata.p2_id;
        } else if (userId == gameData.p2_id) {
            winner = gamedata.p1_id;
        } else {
            console.log("Warning: uninvolved user trying to quit game.");
            return;
        }

        fetch("/finishgame", { 
            method: "POST",
            headers : {"Content-Type": "application/json"},
            body: JSON.stringify({"gameId": gameId, "winner": winner})
        }).then(response =>{
            console.log(response.status);
            if (response.status == 200){
                window.location.href = "https://basicwars.fly.dev/";
            }
        })
        
    }
    function displayLoggedInUser() {
        const loggedInUserDiv = document.getElementById("loggedinUser");
        const userId = parseInt(getUserId());
    
        if (userId) {
            // Make a request to the server to get the username
            fetch(`/username/${userId}`, {
                headers: {
                    'Content-Type': 'application/json'
                }
            })  .then(response => response.json())
                .then(data => {
                    if (data.username) {
                        loggedInUserDiv.textContent = `${data.username}`;
                    } else {
                        loggedInUserDiv.textContent = "Not logged in";
                    }
                })
                .catch(error => {
                    console.error('Error fetching username:', error);
                    loggedInUserDiv.textContent = "Not logged in";
                });
        } else {
            loggedInUserDiv.textContent = "Not logged in";
        }
    }
    // Call the function when the page loads
    displayLoggedInUser();
</script>

</html>
